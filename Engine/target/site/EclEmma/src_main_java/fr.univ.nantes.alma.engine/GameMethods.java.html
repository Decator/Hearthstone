<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>GameMethods.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">fr.univ.nantes.alma.engine (15 janv. 2019 20:58:15)</a> &gt; <a href="../../index.html" class="el_group">Engine</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">fr.univ.nantes.alma.engine</a> &gt; <span class="el_source">GameMethods.java</span></div><h1>GameMethods.java</h1><pre class="source lang-java linenums">package fr.univ.nantes.alma.engine;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.UUID;
import java.util.Vector;


/**
 * Manage all the actions that can happen in the game.
 *
 * @author Alexis Claveau, Martin Ars, Maud Van Dorssen, Alexis Loret
 * @version 0.0.1
 */
public class GameMethods {
  private UUID idGame;
  private Player currentPlayer;
  private Player otherPlayer;
  private boolean gameOver;
  private ArrayList&lt;MinionCard&gt; invocations;

  /**
   * Initialize the attributes of this class.
   * @param idGame the id of the game
   * @param player1 the first player of the game
   * @param player2 the second player of the game
   * @param invocations List of potential invocations
   */
<span class="fc" id="L30">  GameMethods(UUID idGame, Player player1, Player player2, ArrayList&lt;MinionCard&gt; invocations) {</span>
<span class="fc" id="L31">    this.idGame = idGame;</span>
<span class="fc" id="L32">    this.currentPlayer = player1;</span>
<span class="fc" id="L33">    this.otherPlayer = player2;</span>
<span class="fc" id="L34">    this.invocations = invocations;</span>
<span class="fc" id="L35">    this.gameOver = false;</span>
<span class="fc" id="L36">    initTurn();</span>
<span class="fc" id="L37">  }</span>
  
  /**
   * Empty Constructor for GameMethods.
   */
<span class="fc" id="L42">  GameMethods() {}</span>
  
  /**
   * Get the id of the game.
   * @return the id of the game
   */
  public UUID getIdGame() {
<span class="fc" id="L49">    return this.idGame;</span>
  }

  /**
   * Get the current player.
   * @return the player
   */
  public Player getCurrentPlayer() {
<span class="fc" id="L57">    return this.currentPlayer;</span>
  }
  
  /**
   * Sets the current player.
   * @param currentPlayer the current player
   */
  public void setCurrentPlayer(Player currentPlayer) {
<span class="fc" id="L65">    this.currentPlayer = currentPlayer;</span>
<span class="fc" id="L66">  }</span>

  /**
   * Get the other player.
   * @return the player
   */
  public Player getOtherPlayer() {
<span class="fc" id="L73">    return this.otherPlayer;</span>
  }
  
  /**
   * Sets the other player.
   * @param otherPlayer the other player
   */
  public void setOtherPlayer(Player otherPlayer) {
<span class="fc" id="L81">    this.otherPlayer = otherPlayer;</span>
<span class="fc" id="L82">  }</span>
  
  /**
   * Get the game over status of the game.
   * @return true if the game is over, else false
   */
  public boolean isGameOver() {
<span class="fc" id="L89">    return this.gameOver;</span>
  }
  
  /**
   * Sets the gameOver status of the game.
   * @param gameOver true if the game is over, else false
   */
  public void setGameOver(boolean gameOver) {
<span class="fc" id="L97">    this.gameOver = gameOver;</span>
<span class="fc" id="L98">  }</span>
  
  /**
   * Get the list of potential invocations.
   * @return the list of potential invocations
   */
  public ArrayList&lt;MinionCard&gt; getInvocations() {
<span class="fc" id="L105">    return this.invocations;</span>
  }
  
  /**
   * Sets the list of potential invocations.
   * @param invocations the list of potential invocations
   */
  public void setInvocations(ArrayList&lt;MinionCard&gt; invocations) {
<span class="fc" id="L113">    this.invocations = invocations;</span>
<span class="fc" id="L114">  }</span>
  
  /**
   * Play the card with the specified id.
   * @param uuidPlayer the uuid of the player who uses it
   * @param idCard the id of the card the player wants to play
   * @param targetPlayer the player that might be the target of the played card
   * @param idTarget the id of the target
   * @throws EngineException custom exception
   */
  void playCard(UUID uuidPlayer, int idCard, Player targetPlayer, int idTarget) 
      throws EngineException  {
<span class="fc bfc" id="L126" title="All 2 branches covered.">    if (this.currentPlayer.getUuid().equals(uuidPlayer)) {</span>
<span class="fc" id="L127">      AbstractCard card = null; // Create the card according to the id given on parameters</span>
<span class="fc" id="L128">      HeroCard hero = this.currentPlayer.getHero();</span>
<span class="fc bfc" id="L129" title="All 4 branches covered.">      if (idCard &gt;= 0 &amp;&amp; idCard &lt; this.currentPlayer.getHand().size()) {</span>
<span class="fc" id="L130">        card = this.currentPlayer.getHand().get(idCard);</span>
        // If the player has enough mana, play the card
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (GameRuleUtil.checkManaPool(this.currentPlayer.getManaPool(), card.getManaCost())) { </span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">          if (card instanceof MinionCard) { // If it's a Minion</span>
<span class="fc" id="L134">            summonMinionFromHand(idCard);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">          } else if (card instanceof SpellCard) {</span>
<span class="fc" id="L136">            this.currentPlayer.removeCardFromHand(idCard);</span>
<span class="fc" id="L137">            SpellCard spell = (SpellCard) card;</span>
<span class="fc" id="L138">            spellDrawingEffect(spell);</span>
<span class="fc" id="L139">            spellArmorBuffing(hero, spell);</span>
<span class="fc" id="L140">            spellSummoningEffect(spell);</span>
<span class="fc" id="L141">            spellAttackBuffingEffect(targetPlayer, idTarget, spell);</span>
<span class="fc" id="L142">            spellPolymorphingEffect(targetPlayer, idTarget, spell);</span>
<span class="fc" id="L143">            spellDamageEffect(targetPlayer, idTarget, spell);</span>
<span class="fc" id="L144">          } else {</span>
<span class="fc" id="L145">            throw new EngineException(&quot;Ceci n'est pas une carte valide !&quot;);</span>
          }
          // Decrements manaCost from player's manaPool
<span class="fc" id="L148">          this.currentPlayer.setManaPoolAfterPlay(card.getManaCost()); </span>
<span class="fc" id="L149">        } else {</span>
<span class="fc" id="L150">          throw new EngineException(&quot;Vous n'avez pas assez de mana !&quot;);</span>
        }
      } else {
<span class="fc" id="L153">        throw new EngineException(&quot;Votre carte est inexistante !&quot;);</span>
      }
    } else {
<span class="fc" id="L156">      throw new EngineException(&quot;Ce n'est pas votre tour !&quot;);</span>
    }
<span class="fc" id="L158">  }</span>

  /**
   * Summons a minion from the nad of the player onto the board.
   * @param idCard Hand index of the minion to summon
   * @throws EngineException custom exception
   */
  void summonMinionFromHand(int idCard) throws EngineException {
<span class="fc bfc" id="L166" title="All 2 branches covered.">    if (GameRuleUtil.checkBoardSize(this.currentPlayer.getBoard())) {</span>
<span class="fc" id="L167">      this.currentPlayer.addCardToBoard((MinionCard)this.currentPlayer.getHand().get(idCard));</span>
<span class="fc" id="L168">      this.currentPlayer.removeCardFromHand(idCard);</span>
<span class="fc" id="L169">      MinionCard lastMinionPlayed = this.currentPlayer.getBoard().lastElement();</span>
<span class="fc" id="L170">      charge(lastMinionPlayed);</span>
      //give attack aura buff to other minions if it exists
<span class="fc" id="L172">      giveAttackAuraToOtherMinions(this.currentPlayer.getBoard(), lastMinionPlayed);</span>
      // get attack auras buffs from other minions if they exist
<span class="fc" id="L174">      getAttackAuraFromOtherMinions(this.currentPlayer.getBoard(), lastMinionPlayed);</span>
<span class="fc" id="L175">    } else {</span>
<span class="fc" id="L176">      throw new EngineException(&quot;Vous avez atteint &quot;</span>
          + &quot;le nombre maximum de serviteurs sur le plateau !&quot;);
    }
<span class="fc" id="L179">  }</span>

  /**
   * Deals damage to targets depending on the spell.
   * @param targetPlayer player targeted by the spell
   * @param idTarget board in dex of the target of the spell
   * @param spell spell being cast
   */
  void spellDamageEffect(Player targetPlayer, int idTarget, SpellCard spell) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">    if (spell.getDamage() &gt; 0) {</span>
<span class="fc" id="L189">      LinkedHashMap&lt;String, AbstractCard&gt; targets = targetsFromTargetString(this.currentPlayer, </span>
<span class="fc" id="L190">          this.otherPlayer, targetPlayer, idTarget, spell.getTarget());</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">      for (Map.Entry&lt;String, AbstractCard&gt; entry : targets.entrySet()) {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (entry.getValue() instanceof HeroCard) {</span>
<span class="fc" id="L193">          ((HeroCard) entry.getValue()).receiveDamage(spell.getDamage());</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">          if (!GameRuleUtil.checkAlive(((HeroCard)entry.getValue()).getHealthPoints())) {</span>
<span class="fc" id="L195">            this.gameOver = true;</span>
          }
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        } else if (entry.getValue() instanceof MinionCard) {</span>
<span class="fc" id="L198">          ((MinionCard) entry.getValue()).receiveDamage(spell.getDamage());</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">          if (!GameRuleUtil.checkAlive(((MinionCard) entry.getValue()).getHealthPoints())) {</span>
<span class="fc" id="L200">            String[] keys = entry.getKey().split(&quot;_&quot;);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (keys[0].equals(&quot;0&quot;)) {</span>
              //remove attack buff from other minions if relevant
<span class="fc" id="L203">              removeAttackAuraFromMinions(this.currentPlayer.getBoard(), </span>
<span class="fc" id="L204">                  (MinionCard) entry.getValue());</span>
              //If minion healthPoints &lt;= 0, remove minion from board
<span class="fc" id="L206">              this.currentPlayer.removeCardFromBoard(Integer.parseInt(keys[1]));</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            } else if (keys[0].equals(&quot;1&quot;)) {</span>
              //remove attack buff from other minions if relevant
<span class="fc" id="L209">              removeAttackAuraFromMinions(this.otherPlayer.getBoard(), </span>
<span class="fc" id="L210">                  (MinionCard) entry.getValue());</span>
              //If minion healthPoints &lt;= 0, remove minion from board
<span class="fc" id="L212">              this.otherPlayer.removeCardFromBoard(Integer.parseInt(keys[1]));</span>
            }
          }
        }
      }
    }
<span class="fc" id="L218">  }</span>

  /**
   * Polymorphs a specific minion.
   * @param targetPlayer player controlling the minion being polymorphed
   * @param idTarget board index of the minion being polymorphed
   * @param spell spell being cast
   * @throws EngineException custom exception
   */
  void spellPolymorphingEffect(Player targetPlayer, int idTarget, 
      SpellCard spell) throws EngineException {
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (spell.isPolymorph()) {</span>
<span class="fc" id="L230">      LinkedHashMap&lt;String, AbstractCard&gt; targets = targetsFromTargetString(this.currentPlayer, </span>
<span class="fc" id="L231">          this.otherPlayer, targetPlayer, idTarget, spell.getTarget());</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">      for (Map.Entry&lt;String, AbstractCard&gt; entry : targets.entrySet()) {</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (entry.getValue() instanceof MinionCard) {</span>
<span class="fc" id="L234">          String[] keys = entry.getKey().split(&quot;_&quot;);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">          if (keys[0].equals(&quot;0&quot;)) {</span>
<span class="fc" id="L236">            removeAttackAuraFromMinions(this.currentPlayer.getBoard(), </span>
<span class="fc" id="L237">                (MinionCard) entry.getValue());</span>
<span class="fc" id="L238">            polymorph(this.currentPlayer, spell.getIdInvocation(), keys[1]);    </span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">          } else if (keys[0].equals(&quot;1&quot;)) {</span>
<span class="fc" id="L240">            removeAttackAuraFromMinions(this.otherPlayer.getBoard(), (MinionCard) entry.getValue());</span>
<span class="fc" id="L241">            polymorph(this.otherPlayer, spell.getIdInvocation(), keys[1]);</span>
          }
        }
      }
    }
<span class="fc" id="L246">  }</span>

  /**
   * Buffs the attack of a minion according to the spell.
   * @param targetPlayer player controlling the minion
   * @param idTarget board index of the minion
   * @param spell the spell that is cast
   */
  void spellAttackBuffingEffect(Player targetPlayer, int idTarget, SpellCard spell) {
<span class="fc bfc" id="L255" title="All 2 branches covered.">    if (spell.getAttackBuff() &gt; 0) { // Adds an attack buff to the target minions </span>
<span class="fc" id="L256">      LinkedHashMap&lt;String, AbstractCard&gt; targets = targetsFromTargetString(this.currentPlayer, </span>
<span class="fc" id="L257">          this.otherPlayer, targetPlayer, idTarget, spell.getTarget());</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">      for (Map.Entry&lt;String, AbstractCard&gt; entry : targets.entrySet()) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (entry.getValue() instanceof MinionCard) {</span>
<span class="fc" id="L260">          ((MinionCard)entry.getValue()).setDamage(((MinionCard)entry.getValue()).getDamage() </span>
<span class="fc" id="L261">              + spell.getAttackBuff());</span>
        }
      }
    }
<span class="fc" id="L265">  }</span>

  /**
   * Summons minions according to the spell.
   * @param spell the spell that is cast
   * @throws EngineException custom exception
   */
  void spellSummoningEffect(SpellCard spell) throws EngineException {
<span class="fc bfc" id="L273" title="All 4 branches covered.">    if (spell.getNbSummon() &gt; 0 &amp;&amp; !spell.isPolymorph()) { // Summon specific minions on the board</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">      for (int i = 0; i &lt; spell.getNbSummon(); i++) { // Summon as many minions as needed</span>
<span class="fc" id="L275">        summonMinion(this.currentPlayer, spell.getIdInvocation());</span>
      }
    }
<span class="fc" id="L278">  }</span>

  /**
   * Draws card according to the spell.
   * @param spell the spell that is cast
   * @throws EngineException custom exception
   */
  void spellDrawingEffect(SpellCard spell) throws EngineException {
<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (spell.getNbDraw() &gt; 0) { // Add cards to hand if relevant</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">      for (int i = 0; i &lt; spell.getNbDraw(); i++) { // Draw as many cards as needed</span>
<span class="fc" id="L288">        drawCard();</span>
      }
    }
<span class="fc" id="L291">  }</span>

  /**
   * Gives armorPoints to the hero using the spell.
   * @param hero the hero using the spell.
   * @param spell the spell being used.
   */
  void spellArmorBuffing(HeroCard hero, SpellCard spell) {
<span class="fc bfc" id="L299" title="All 2 branches covered.">    if (spell.getArmorBuff() &gt; 0) { // Adds Armor points if relevant</span>
<span class="fc" id="L300">      hero.setArmorPoints(hero.getArmorPoints() + spell.getArmorBuff());</span>
    }
<span class="fc" id="L302">  }</span>
  
  /**
   * Triggers the hero power of the current player based on its class.
   * @param uuidPlayer the uuid of the player who uses it
   * @param playerTarget the player that might be the target of the hero power
   * @param idTarget the specific target of the hero power
   * @throws EngineException custom exception
   */
  void heroPower(UUID uuidPlayer, Player playerTarget, int idTarget) throws EngineException {
<span class="fc bfc" id="L312" title="All 2 branches covered.">    if (this.currentPlayer.getUuid().equals(uuidPlayer)) {</span>
<span class="fc" id="L313">      HeroCard heroCurrentPlayer = this.currentPlayer.getHero();</span>
      // If the hero has already used his power
<span class="fc bfc" id="L315" title="All 2 branches covered.">      if (!heroCurrentPlayer.isHeroPowerUsed()) { </span>
<span class="fc" id="L316">        if (GameRuleUtil.checkManaPool(this.currentPlayer.getManaPool(), </span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            GameRuleUtil.MANA_HERO_POWER)) {</span>
<span class="fc bfc" id="L318" title="All 4 branches covered.">          switch (heroCurrentPlayer.getType()) {</span>
            case &quot;warrior&quot;:
<span class="fc" id="L320">              heroCurrentPlayer.setArmorPoints(heroCurrentPlayer.getArmorPoints() </span>
<span class="fc" id="L321">                  + heroCurrentPlayer.getArmorBuff());</span>
<span class="fc" id="L322">              heroCurrentPlayer.setHeroPowerUsed(true);</span>
<span class="fc" id="L323">              this.currentPlayer.setManaPoolAfterPlay(GameRuleUtil.MANA_HERO_POWER);</span>
<span class="fc" id="L324">              break;</span>
            case &quot;mage&quot;:
<span class="fc" id="L326">              mageHeroPower(playerTarget, idTarget, heroCurrentPlayer);</span>
<span class="fc" id="L327">              heroCurrentPlayer.setHeroPowerUsed(true);</span>
<span class="fc" id="L328">              this.currentPlayer.setManaPoolAfterPlay(GameRuleUtil.MANA_HERO_POWER);</span>
<span class="fc" id="L329">              break;</span>
            case &quot;paladin&quot;:
<span class="fc" id="L331">              summonMinion(currentPlayer, heroCurrentPlayer.getIdInvocation());</span>
<span class="fc" id="L332">              heroCurrentPlayer.setHeroPowerUsed(true);</span>
<span class="fc" id="L333">              currentPlayer.setManaPoolAfterPlay(GameRuleUtil.MANA_HERO_POWER);</span>
<span class="fc" id="L334">              break;</span>
            default :
<span class="fc" id="L336">              heroCurrentPlayer.setHeroPowerUsed(true);</span>
<span class="fc" id="L337">              currentPlayer.setManaPoolAfterPlay(GameRuleUtil.MANA_HERO_POWER);</span>
<span class="fc" id="L338">              throw new EngineException(&quot;Impossible de récupérer la classe du héros !&quot;);</span>
          }
<span class="nc" id="L340">        } else {</span>
<span class="fc" id="L341">          throw new EngineException(&quot;Vous n'avez pas assez de mana !&quot;);</span>
        }
      } else {
<span class="fc" id="L344">        throw new EngineException(&quot;Vous avez déjà utilisé votre pouvoir héroïque durant ce tour !&quot;);</span>
      }
    } else {
<span class="fc" id="L347">      throw new EngineException(&quot;Ce n'est pas votre tour !&quot;);</span>
    }
<span class="fc" id="L349">  }</span>

  /**
   * Activates the hero power of the mage, thus dealing some damage to a target.
   * @param playerTarget player target of the hero power
   * @param idTarget board index of the actual target of the hero power
   * @param heroCurrentPlayer hero of the player using the hero power
   */
  void mageHeroPower(Player playerTarget, int idTarget, HeroCard heroCurrentPlayer) {
<span class="fc bfc" id="L358" title="All 2 branches covered.">    if (heroCurrentPlayer.getDamage() &gt; 0) {</span>
<span class="fc" id="L359">      LinkedHashMap&lt;String, AbstractCard&gt; targets = targetsFromTargetString(this.currentPlayer, </span>
<span class="fc" id="L360">          this.otherPlayer, playerTarget, idTarget, heroCurrentPlayer.getTarget());</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      for (Map.Entry&lt;String, AbstractCard&gt; entry : targets.entrySet()) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (entry.getValue() instanceof HeroCard) {</span>
<span class="fc" id="L363">          ((HeroCard) entry.getValue()).receiveDamage(heroCurrentPlayer.getDamage());</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">          if (!GameRuleUtil.checkAlive(((HeroCard)entry.getValue()).getHealthPoints())) {</span>
<span class="fc" id="L365">            this.gameOver = true;</span>
          }
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        } else if (entry.getValue() instanceof MinionCard) {</span>
<span class="fc" id="L368">          ((MinionCard) entry.getValue()).receiveDamage(heroCurrentPlayer.getDamage());</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">          if (!GameRuleUtil.checkAlive(((MinionCard) entry.getValue()).getHealthPoints())) {</span>
<span class="fc" id="L370">            String[] keys = entry.getKey().split(&quot;_&quot;);</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            if (keys[0].equals(&quot;0&quot;)) { </span>
<span class="fc" id="L372">              removeAttackAuraFromMinions(this.currentPlayer.getBoard(), </span>
<span class="fc" id="L373">                  (MinionCard) entry.getValue());</span>
<span class="fc" id="L374">              this.currentPlayer.removeCardFromBoard(Integer.parseInt(keys[1]));</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">            } else if (keys[0].equals(&quot;1&quot;)) {</span>
<span class="fc" id="L376">              removeAttackAuraFromMinions(this.otherPlayer.getBoard(), (MinionCard) entry.getValue());</span>
<span class="fc" id="L377">              this.otherPlayer.removeCardFromBoard(Integer.parseInt(keys[1]));</span>
            }
          }
        }
      }
    }
<span class="fc" id="L383">  }</span>
  
  /**
   * Attacks a target with an attacker given in parameter.
   * @param uuidPlayer the uuid of the player who uses it
   * @param idAttack the id of the attacker
   * @param uuidTarget the uuid of the targeted player
   * @param idTarget the id of the target
   * @throws EngineException custom exception
   */
  void attack(UUID uuidPlayer, int idAttack, UUID uuidTarget, int idTarget) throws EngineException {
<span class="fc bfc" id="L394" title="All 2 branches covered.">    if (this.currentPlayer.getUuid().equals(uuidPlayer)) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">      if (this.otherPlayer.getUuid().equals(uuidTarget)) {</span>
<span class="fc" id="L396">        MinionCard minion = this.currentPlayer.getBoard().get(idAttack);</span>
<span class="fc" id="L397">        HeroCard hero = this.currentPlayer.getHero();</span>
<span class="fc" id="L398">        HeroCard heroEnemy = this.otherPlayer.getHero();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (minion.getDamage() &gt; 0) {</span>
          //Checks if the minion already attacked or not
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">          if (minion != null &amp;&amp; !GameRuleUtil.checkMinionAttacked(minion)) {</span>
            /* If no enemy minion has taunt and enemy Hero is target, 
            then attacking is possible*/
<span class="pc bpc" id="L404" title="1 of 4 branches missed.">            if (!taunt(this.otherPlayer.getBoard()) &amp;&amp; idTarget == -1) { </span>
<span class="fc" id="L405">              int damage = minion.getDamage();</span>
<span class="fc" id="L406">              heroEnemy.receiveDamage(damage); //attacks the enemy Hero</span>
<span class="fc" id="L407">              minion.setAttacked(true);</span>
<span class="fc" id="L408">              lifesteal(hero, minion);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">              if (!GameRuleUtil.checkAlive(heroEnemy.getHealthPoints())) {</span>
<span class="fc" id="L410">                this.gameOver = true;</span>
              }
              /* If no enemy minion has taunt, 
              or target minion has taunt, attacking is possible*/
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            } else if (!taunt(this.otherPlayer.getBoard()) </span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                || this.otherPlayer.getBoard().get(idTarget).isTaunt()) { </span>
<span class="fc" id="L416">              MinionCard victim = this.otherPlayer.getBoard().get(idTarget);</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">              if (victim != null) {</span>
<span class="fc" id="L418">                minion.receiveDamage(victim.getDamage()); // minion takes victim's damage</span>
<span class="fc" id="L419">                lifesteal(hero, minion);</span>
<span class="fc" id="L420">                victim.receiveDamage(minion.getDamage()); //attacks the minion</span>
<span class="fc" id="L421">                lifesteal(heroEnemy, victim);</span>
<span class="fc" id="L422">                minion.setAttacked(true);</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">                if (!GameRuleUtil.checkAlive(minion.getHealthPoints())) {</span>
                  //removes attack buff from other minions if relevant
<span class="fc" id="L425">                  removeAttackAuraFromMinions(this.currentPlayer.getBoard(), minion);</span>
<span class="fc" id="L426">                  this.currentPlayer.removeCardFromBoard(idAttack);</span>
                }
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (!GameRuleUtil.checkAlive(victim.getHealthPoints())) {</span>
                  //removes attack buff from other minions if relevant
<span class="fc" id="L430">                  removeAttackAuraFromMinions(this.otherPlayer.getBoard(), victim);</span>
<span class="fc" id="L431">                  this.otherPlayer.removeCardFromBoard(idTarget);</span>
                }
<span class="fc" id="L433">              } else {</span>
<span class="nc" id="L434">                throw new EngineException(&quot;Le serviteur que vous cherchez à attaquer n'existe pas !&quot;);</span>
              }
            } else {
<span class="fc" id="L437">              throw new EngineException(&quot;Cible incorrecte, un serviteur adverse a provocation !&quot;);</span>
            }
          } else {
<span class="fc" id="L440">            throw new EngineException(&quot;Ce serviteur a déjà attaqué durant ce tour !&quot;);</span>
          }
        } else {
<span class="fc" id="L443">          throw new EngineException(&quot;Ce serviteur ne peut pas attaquer !&quot;);</span>
        }
      } else {
<span class="fc" id="L446">        throw new EngineException(&quot;Vous ne pouvez attaquer que l'adversaire !&quot;);</span>
      }
    } else {
<span class="fc" id="L449">      throw new EngineException(&quot;Ce n'est pas votre tour !&quot;);</span>
    }
<span class="fc" id="L451">  }</span>
  
  /**
   * Initializes manaMaxTurn, manaPool, heroPowerUsed and minionAttacked for 
   * the beginning of the turn.
   */
  void initTurn() {
<span class="fc" id="L458">    Player player = this.currentPlayer;</span>
<span class="fc" id="L459">    HeroCard hero = this.currentPlayer.getHero();</span>
    try {
<span class="fc" id="L461">      drawCard();</span>
<span class="fc" id="L462">    } catch (EngineException e) {</span>
    } finally {
<span class="fc bfc" id="L464" title="All 2 branches covered.">      if (GameRuleUtil.checkManaTurn(player.getManaMaxTurn())) {</span>
<span class="fc" id="L465">        player.setManaMaxTurn();</span>
      }
<span class="fc" id="L467">      player.setManaPoolForNewTurn();</span>
<span class="fc" id="L468">      hero.setHeroPowerUsed(false);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">      for (MinionCard minion : player.getBoard()) {</span>
<span class="fc" id="L470">        minion.setAttacked(false);</span>
      }
    }
<span class="fc" id="L473">  }</span>
  
  /**
   * End the turn of the current player and switches to the other player.
   * @param uuidPlayer the uuid of the player who uses it
   * @throws EngineException custom exception
   */
  void endTurn(UUID uuidPlayer) throws EngineException {
<span class="fc bfc" id="L481" title="All 2 branches covered.">    if (this.currentPlayer.getUuid().equals(uuidPlayer)) {</span>
<span class="fc" id="L482">      Player tmp = this.currentPlayer;</span>
<span class="fc" id="L483">      this.currentPlayer = this.otherPlayer;</span>
<span class="fc" id="L484">      this.otherPlayer = tmp;</span>
<span class="fc" id="L485">      initTurn();</span>
<span class="fc" id="L486">    } else {</span>
<span class="fc" id="L487">      throw new EngineException(&quot;Ce n'est pas votre tour !&quot;);</span>
    }
<span class="fc" id="L489">  }</span>
  
  /**
   * Draws a card from the player's deck and place it into his hand.
   * @throws EngineException custom exception
   */
  void drawCard() throws EngineException {
<span class="fc" id="L496">    Player player = this.currentPlayer;</span>
<span class="fc" id="L497">    int random = (int)(player.getDeck().length * Math.random());</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">    if (GameRuleUtil.checkHandSize(player.getHand())) {</span>
<span class="fc" id="L499">      player.addCardToHand(player.getDeck()[random]);</span>
<span class="fc" id="L500">    } else {</span>
<span class="fc" id="L501">      throw new EngineException(&quot;Votre main est pleine !&quot;);</span>
    }
<span class="fc" id="L503">  }</span>
  
  

  /**
   * Gives attack aura buff from played minion to other minions on the board.
   * @param board board where the minion is summoned
   * @param lastMinionPlayed minion that was just summoned
   */
  void giveAttackAuraToOtherMinions(Vector&lt;MinionCard&gt; board, MinionCard lastMinionPlayed) {
<span class="fc bfc" id="L513" title="All 2 branches covered.">    if (lastMinionPlayed.getAttackBuffAura() &gt; 0) { //if minion has attack aura</span>
<span class="fc" id="L514">      int attackBuffAura = lastMinionPlayed.getAttackBuffAura();</span>
      // gives attack aura to all allies minions but itself
<span class="fc bfc" id="L516" title="All 2 branches covered.">      for (int i = 0; i &lt; board.size() - 1; i++) {</span>
<span class="fc" id="L517">        MinionCard minion = board.get(i);</span>
<span class="fc" id="L518">        minion.setDamage(minion.getDamage() + attackBuffAura);</span>
      }
    }
<span class="fc" id="L521">  }</span>
  
  /**
   * Gets the cumulated attack aura buffs of other minions and add them to the played minion.
   * @param board the board of the player playing the minion
   * @param lastMinionPlayed minion that was just summoned
   */
  void getAttackAuraFromOtherMinions(Vector&lt;MinionCard&gt; board, MinionCard lastMinionPlayed) {
<span class="fc" id="L529">    int attackBuffAura = 0;</span>
    //if there are minions with attack auras on the board
<span class="fc bfc" id="L531" title="All 2 branches covered.">    for (int i = 0; i &lt; board.size() - 1; i++) {</span>
<span class="fc" id="L532">      MinionCard minion = board.get(i);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">      if (minion.getAttackBuffAura() &gt; 0) {</span>
        //add auras up except aura generated by played minion
<span class="fc" id="L535">        attackBuffAura += minion.getAttackBuffAura();</span>
      }
    }
    // gives attack aura to played minion
<span class="fc" id="L539">    lastMinionPlayed.setDamage(lastMinionPlayed.getDamage() + attackBuffAura); </span>
<span class="fc" id="L540">  }</span>
  
  /**
   * Removes the attack aura buff from all minions of the board 
   * upon the death of the minion generating the buff.
   * @param board the board containing the dying minion
   * @param dyingMinion minion that just died
   */
  void removeAttackAuraFromMinions(Vector&lt;MinionCard&gt; board, MinionCard dyingMinion) {
<span class="fc bfc" id="L549" title="All 2 branches covered.">    if (dyingMinion.getAttackBuffAura() &gt; 0) { //if minion has attack aura</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">      for (int i = 0; i &lt; board.size(); i++) {</span>
<span class="fc" id="L551">        board.get(i).setDamage(board.get(i).getDamage() - dyingMinion.getAttackBuffAura());</span>
      }
    }
<span class="fc" id="L554">  }</span>
  
  /**
   * Heals the hero for the damage inflicted by its lifestealing minion.
   * @param hero the hero healed by lifesteal
   * @param minion the minion having lifesteal
   */
  void lifesteal(HeroCard hero, MinionCard minion) {
<span class="fc bfc" id="L562" title="All 2 branches covered.">    if (minion.isLifesteal()) { //check for lifesteal</span>
      //heals for the damage inflicted by the minion
<span class="fc" id="L564">      hero.receiveHealing(minion.getDamage()); </span>
    }
<span class="fc" id="L566">  }</span>
  
  /**
   * If played minion has charge, it can attack right away.
   * @param lastMinionPlayed minion that was last summoned
   */
  void charge(MinionCard lastMinionPlayed) {
<span class="fc bfc" id="L573" title="All 2 branches covered.">    if (lastMinionPlayed.isCharge()) { // If played minion has charge</span>
<span class="fc" id="L574">      lastMinionPlayed.setAttacked(false); //can attack right away</span>
<span class="fc" id="L575">    } else  {</span>
<span class="fc" id="L576">      lastMinionPlayed.setAttacked(true); // else has to wait a turn</span>
    }
<span class="fc" id="L578">  }</span>
  
  /**
   * Checks if a minion in the board of interest has at least one minion with taunt.
   * @param board the board that needs to be checked for taunt minions
   * @return true if a minion as taunt, else false
   */
  boolean taunt(Vector&lt;MinionCard&gt; board) {
<span class="fc bfc" id="L586" title="All 2 branches covered.">    for (MinionCard minionEnemy : board) { // Check if an enemy minion has taunt</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">      if (minionEnemy.isTaunt()) {</span>
<span class="fc" id="L588">        return true;</span>
      }
    }
<span class="fc" id="L591">    return false;</span>
  }
  
  /**
   * Summons a minion on the player's board based on idSummon.
   * @param player the player getting the minion on his board
   * @param idSummon the id of the summoned minion
   * @throws EngineException custom exception
   */
  void summonMinion(Player player, int idSummon) throws EngineException {
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">    if (GameRuleUtil.checkBoardSize(player.getBoard())) { // if board is not full</span>
<span class="fc" id="L602">      MinionCard minion = null;</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">      for (MinionCard invoc : this.invocations) { //get specific minion</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        if (invoc.getId() == idSummon) {</span>
          try {
<span class="fc" id="L606">            minion = (MinionCard) invoc.clone();</span>
<span class="pc" id="L607">          } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L608">            e.printStackTrace();</span>
          }
        }
      }
<span class="fc bfc" id="L612" title="All 2 branches covered.">      if (minion != null) {</span>
<span class="fc" id="L613">        player.addCardToBoard(minion);</span>
<span class="fc" id="L614">        giveAttackAuraToOtherMinions(player.getBoard(), player.getBoard().lastElement());</span>
<span class="fc" id="L615">        getAttackAuraFromOtherMinions(player.getBoard(), player.getBoard().lastElement());</span>
<span class="fc" id="L616">      } else {</span>
<span class="fc" id="L617">        throw new EngineException(&quot;Le minion n'a pas pu être invoqué !&quot;);</span>
      }
    }
<span class="fc" id="L620">  }</span>

  /**
   * Summons the minion replacing the polymorphed minion 
   * at a specified location on the board of the affected player.
   * @param player the player affected by the spell
   * @param idSummon the id of the minion replacing the polymorphed minion
   * @param indexBoard the board index where the minion needs to be summoned
   * @throws EngineException custom exception
   */
  void polymorph(Player player, int idSummon, String indexBoard) throws EngineException {
<span class="fc" id="L631">    MinionCard minion = null;</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">    for (MinionCard invoc : this.invocations) { //get specific minion</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">      if (invoc.getId() == idSummon) {</span>
        try {
<span class="fc" id="L635">          minion = (MinionCard) invoc.clone();</span>
<span class="pc" id="L636">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L637">          e.printStackTrace();</span>
        }
      }
    }
<span class="fc bfc" id="L641" title="All 2 branches covered.">    if (minion != null) {</span>
<span class="fc" id="L642">      player.addCardToBoard(minion, Integer.parseInt(indexBoard)); </span>
<span class="fc" id="L643">      giveAttackAuraToOtherMinions(player.getBoard(), </span>
<span class="fc" id="L644">          player.getBoard().get(Integer.parseInt(indexBoard)));</span>
<span class="fc" id="L645">      getAttackAuraFromOtherMinions(player.getBoard(), </span>
<span class="fc" id="L646">          player.getBoard().get(Integer.parseInt(indexBoard)));</span>
<span class="fc" id="L647">    } else {</span>
<span class="fc" id="L648">      throw new EngineException(&quot;Le minion n'a pas pu être invoqué !&quot;);</span>
    }
<span class="fc" id="L650">  }</span>
  
  /**
   * Returns a list of targets based on the String of a specific spell.
   * @param player the player playing the spell
   * @param playerEnemy the enemy player that may be affected by the spell
   * @param targetPlayer the specific player impacted by the spell if specified
   * @param idTarget the specific target of the spell if specified
   * @param spellTarget the string detailing the potential targets of a given spell
   * @return LinkedHashMap containing the targets of the spell
   */
  public LinkedHashMap&lt;String, AbstractCard&gt; targetsFromTargetString(Player player, 
      Player playerEnemy, Player targetPlayer, int idTarget, String spellTarget) {
<span class="fc" id="L663">    String[] splitString = spellTarget.split(&quot;_&quot;);</span>
<span class="fc" id="L664">    HeroCard hero = player.getHero();</span>
<span class="fc" id="L665">    HeroCard heroEnemy = playerEnemy.getHero();</span>
<span class="fc" id="L666">    LinkedHashMap&lt;String, AbstractCard&gt; targets = new LinkedHashMap&lt;String, AbstractCard&gt;();</span>
<span class="fc bfc" id="L667" title="All 3 branches covered.">    switch (splitString[0]) {</span>
      case &quot;minion&quot; :
<span class="fc bfc" id="L669" title="All 3 branches covered.">        switch (splitString[1]) {</span>
          case &quot;all&quot; :
<span class="fc bfc" id="L671" title="All 4 branches covered.">            switch (splitString[2]) {</span>
              case &quot;enemy&quot; :
<span class="fc bfc" id="L673" title="All 2 branches covered.">                for (int i = playerEnemy.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L674">                  targets.put(&quot;1_&quot; + String.valueOf(i), playerEnemy.getBoard().get(i));</span>
                }
<span class="fc" id="L676">                break;</span>
              case &quot;ally&quot; :
<span class="fc bfc" id="L678" title="All 2 branches covered.">                for (int i = player.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L679">                  targets.put(&quot;0_&quot; + String.valueOf(i), player.getBoard().get(i));</span>
                }
<span class="fc" id="L681">                break;</span>
              case &quot;all&quot; :
<span class="fc bfc" id="L683" title="All 2 branches covered.">                for (int i = playerEnemy.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L684">                  targets.put(&quot;1_&quot; + String.valueOf(i),playerEnemy.getBoard().get(i));</span>
                }
<span class="fc bfc" id="L686" title="All 2 branches covered.">                for (int i = player.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L687">                  targets.put(&quot;0_&quot; + String.valueOf(i), player.getBoard().get(i));</span>
                }
<span class="fc" id="L689">                break;</span>
              default:
                break;
            }
<span class="fc" id="L693">            break;</span>
          case &quot;1&quot; :
<span class="fc bfc" id="L695" title="All 4 branches covered.">            switch (splitString[2]) {</span>
              case &quot;enemy&quot; :
<span class="fc" id="L697">                targets.put(&quot;1_&quot; + String.valueOf(idTarget), playerEnemy.getBoard().get(idTarget));</span>
<span class="fc" id="L698">                break;</span>
              case &quot;ally&quot; :
<span class="fc" id="L700">                targets.put(&quot;0_&quot; + String.valueOf(idTarget), player.getBoard().get(idTarget));</span>
<span class="fc" id="L701">                break;</span>
              case &quot;all&quot; :
<span class="fc bfc" id="L703" title="All 2 branches covered.">                if (targetPlayer.getUuid().equals(player.getUuid())) {</span>
<span class="fc" id="L704">                  targets.put(&quot;0_&quot; + String.valueOf(idTarget), player.getBoard().get(idTarget));</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">                } else if (targetPlayer.getUuid().equals(playerEnemy.getUuid())) {</span>
<span class="fc" id="L706">                  targets.put(&quot;1_&quot; + String.valueOf(idTarget), </span>
<span class="fc" id="L707">                      playerEnemy.getBoard().get(idTarget));</span>
                }
<span class="fc" id="L709">                break;</span>
              default:
                break;
            }
<span class="fc" id="L713">            break;</span>
          default:
            break;
        }
<span class="fc" id="L717">        break;</span>
      case &quot;all&quot; :
<span class="fc bfc" id="L719" title="All 3 branches covered.">        switch (splitString[1]) {</span>
          case &quot;all&quot; :
<span class="fc bfc" id="L721" title="All 4 branches covered.">            switch (splitString[2]) {</span>
              case &quot;enemy&quot; :
<span class="fc bfc" id="L723" title="All 2 branches covered.">                for (int i = playerEnemy.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L724">                  targets.put(&quot;1_&quot; + String.valueOf(i),playerEnemy.getBoard().get(i));</span>
                }
<span class="fc" id="L726">                targets.put(&quot;1&quot;,heroEnemy);</span>
<span class="fc" id="L727">                break;</span>
              case &quot;ally&quot; :
<span class="fc bfc" id="L729" title="All 2 branches covered.">                for (int i = player.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L730">                  targets.put(&quot;0_&quot; + String.valueOf(i), player.getBoard().get(i));</span>
                }
<span class="fc" id="L732">                targets.put(&quot;0&quot;, hero);</span>
<span class="fc" id="L733">                break;</span>
              case &quot;all&quot; :
<span class="fc bfc" id="L735" title="All 2 branches covered.">                for (int i = player.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L736">                  targets.put(&quot;0_&quot; + String.valueOf(i), player.getBoard().get(i));</span>
                }
<span class="fc bfc" id="L738" title="All 2 branches covered.">                for (int i = playerEnemy.getBoard().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L739">                  targets.put(&quot;1_&quot; + String.valueOf(i), playerEnemy.getBoard().get(i));</span>
                }
<span class="fc" id="L741">                targets.put(&quot;0&quot;,hero);</span>
<span class="fc" id="L742">                targets.put(&quot;1&quot;, heroEnemy);</span>
<span class="fc" id="L743">                break;</span>
              default:
                break;
            }
<span class="fc" id="L747">            break;</span>
          case &quot;1&quot; :
<span class="fc bfc" id="L749" title="All 4 branches covered.">            switch (splitString[2]) {</span>
              case &quot;enemy&quot; :
<span class="fc bfc" id="L751" title="All 2 branches covered.">                if (idTarget == -1) {</span>
<span class="fc" id="L752">                  targets.put(&quot;1&quot;, heroEnemy);</span>
<span class="fc" id="L753">                } else {</span>
<span class="fc" id="L754">                  targets.put(&quot;1_&quot; + String.valueOf(idTarget), </span>
<span class="fc" id="L755">                      playerEnemy.getBoard().get(idTarget));</span>
                }
<span class="fc" id="L757">                break;</span>
              case &quot;ally&quot; :
<span class="fc bfc" id="L759" title="All 2 branches covered.">                if (idTarget == -1) {</span>
<span class="fc" id="L760">                  targets.put(&quot;0&quot;, hero);</span>
<span class="fc" id="L761">                } else {</span>
<span class="fc" id="L762">                  targets.put(&quot;0_&quot; + String.valueOf(idTarget), player.getBoard().get(idTarget));</span>
                }
<span class="fc" id="L764">                break;</span>
              case &quot;all&quot; :
<span class="fc bfc" id="L766" title="All 2 branches covered.">                if (targetPlayer.getUuid().equals(player.getUuid())) {</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                  if (idTarget == -1) {</span>
<span class="fc" id="L768">                    targets.put(&quot;0&quot;, hero);</span>
<span class="fc" id="L769">                  } else {</span>
<span class="fc" id="L770">                    targets.put(&quot;0_&quot; + String.valueOf(idTarget), player.getBoard().get(idTarget));</span>
                  }
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">                } else if (targetPlayer.getUuid().equals(playerEnemy.getUuid())) {</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">                  if (idTarget == -1) {</span>
<span class="fc" id="L774">                    targets.put(&quot;1&quot;, heroEnemy);</span>
<span class="fc" id="L775">                  } else {</span>
<span class="fc" id="L776">                    targets.put(&quot;1_&quot; + String.valueOf(idTarget), </span>
<span class="fc" id="L777">                        playerEnemy.getBoard().get(idTarget));</span>
                  }
                }
<span class="fc" id="L780">                break;</span>
              default:
                break;
            }
<span class="fc" id="L784">            break;</span>
          default:
            break;
        }
<span class="fc" id="L788">        break;</span>
      default:
        break;
    }
<span class="fc" id="L792">    return targets;</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span>fr.univ.nantes.alma.engine (15 janv. 2019 20:58:15)</div></body></html>